"""
硬件测试文件生成器 - 人脸识别
生成Verilog testbench、BRAM初始化文件、C头文件
"""
import numpy as np
from sklearn.datasets import fetch_olivetti_faces
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import MinMaxScaler
from sklearn.decomposition import PCA


class FaceHardwareGenerator:
    def __init__(self, n_components=50):
        """初始化硬件文件生成器"""
        self.n_components = n_components
        self.load_dataset()

    def load_dataset(self):
        """加载数据集"""
        print("=" * 70)
        print("硬件测试文件生成器 - 人脸识别")
        print("=" * 70)

        faces = fetch_olivetti_faces(shuffle=True, random_state=42)
        X_raw = faces.data
        y = faces.target

        pca = PCA(n_components=self.n_components, random_state=42)
        X_pca = pca.fit_transform(X_raw)

        scaler = MinMaxScaler(feature_range=(0, 255))
        X_scaled = scaler.fit_transform(X_pca)
        self.X = np.round(X_scaled).astype(np.uint8)
        self.y = y

        self.X_train, self.X_test, self.y_train, self.y_test = train_test_split(
            self.X, self.y, test_size=0.2, random_state=42, stratify=self.y
        )

        print(f"训练集: {len(self.X_train)} 张人脸")
        print(f"测试集: {len(self.X_test)} 张人脸")
        print(f"特征维度: {self.X_train.shape[1]}")

    def generate_bram_mem(self, filename='face_train_data_bram.mem'):
        """生成BRAM初始化文件（.mem格式）"""
        print(f"\n生成BRAM初始化文件: {filename}")

        with open(filename, 'w') as f:
            f.write(f"// Face Recognition Training Data - BRAM Format\n")
            f.write(f"// Generated by hardware_testbench_generator.py\n")
            f.write(f"// Total Faces: {len(self.X_train)}\n")
            f.write(f"// Features per Face: {self.X_train.shape[1]}\n")
            f.write(f"// Data Width: 8-bit (uint8)\n")
            f.write(f"// Memory Organization: [label][feature0][feature1]...[featureN]\n")
            f.write(f"// Each face occupies {self.X_train.shape[1] + 1} addresses\n\n")

            for i, (features, label) in enumerate(zip(self.X_train, self.y_train)):
                base_addr = i * (self.X_train.shape[1] + 1)

                # 写入标签
                f.write(f"@{base_addr:08X} {label:02X}  // Face {i}: Person ID = {label}\n")

                # 写入特征（每8个特征一行）
                for j in range(0, len(features), 8):
                    chunk = features[j:min(j+8, len(features))]
                    for k, feature in enumerate(chunk):
                        addr = base_addr + j + k + 1
                        f.write(f"@{addr:08X} {feature:02X}\n")

        print(f"✓ 已生成 {filename}")
        print(f"  - 总地址数: {len(self.X_train) * (self.X_train.shape[1] + 1)}")

    def generate_coe_file(self, filename='face_train_data.coe'):
        """生成Vivado COE文件"""
        print(f"\n生成Vivado COE文件: {filename}")

        with open(filename, 'w') as f:
            f.write("; Face Recognition Training Data - Vivado COE Format\n")
            f.write(f"; Total Faces: {len(self.X_train)}\n")
            f.write(f"; Features: {self.X_train.shape[1]}\n")
            f.write("; Data format: [label][features...]\n")
            f.write("memory_initialization_radix=16;\n")
            f.write("memory_initialization_vector=\n")

            data_list = []
            for features, label in zip(self.X_train, self.y_train):
                data_list.append(f"{label:02X}")
                for feature in features:
                    data_list.append(f"{feature:02X}")

            # COE格式要求最后一个用分号
            for i, data in enumerate(data_list):
                if i == len(data_list) - 1:
                    f.write(f"{data};")
                else:
                    f.write(f"{data},")
                    if (i + 1) % 16 == 0:
                        f.write("\n")

        print(f"✓ 已生成 {filename}")

    def generate_test_vectors(self, filename='face_test_vectors.mem', num_tests=20):
        """生成Verilog testbench测试向量"""
        print(f"\n生成测试向量文件: {filename}")

        test_samples = self.X_test[:num_tests]
        test_labels = self.y_test[:num_tests]

        with open(filename, 'w') as f:
            f.write("// Face Recognition Test Vectors\n")
            f.write(f"// Number of Tests: {num_tests}\n")
            f.write(f"// Features: {self.X_train.shape[1]}\n")
            f.write("// Format: test_id | features (hex) | expected_label\n")
            f.write("// Usage: Read this file in your Verilog testbench\n\n")

            for i, (features, label) in enumerate(zip(test_samples, test_labels)):
                f.write(f"// ============================================\n")
                f.write(f"// Test {i + 1}: Expected Person ID = {label}\n")
                f.write(f"// ============================================\n")

                # 生成特征向量（按8个特征一行）
                for j in range(0, len(features), 8):
                    chunk = features[j:j + 8]
                    hex_str = ' '.join([f"{x:02X}" for x in chunk])
                    f.write(f"{hex_str}\n")

                f.write(f"EXPECTED: {label:02X}\n")
                f.write("\n")

        print(f"✓ 已生成 {filename}")
        print(f"  - 测试样本数: {num_tests}")

    def generate_c_header(self, filename='face_knn_data.h'):
        """生成ARM端C程序头文件"""
        print(f"\n生成C头文件: {filename}")

        with open(filename, 'w') as f:
            f.write("/* Face Recognition KNN Data - ARM C Header */\n")
            f.write("/* Generated by hardware_testbench_generator.py */\n")
            f.write("#ifndef FACE_KNN_DATA_H\n")
            f.write("#define FACE_KNN_DATA_H\n\n")
            f.write("#include <stdint.h>\n\n")

            # 常量定义
            f.write("// Dataset dimensions\n")
            f.write(f"#define N_TRAIN_FACES {len(self.X_train)}\n")
            f.write(f"#define N_TEST_FACES {len(self.X_test)}\n")
            f.write(f"#define N_FEATURES {self.X_train.shape[1]}\n")
            f.write(f"#define N_PERSONS {len(np.unique(self.y_train))}\n\n")

            f.write("// Adaptive K-NN parameters\n")
            f.write(f"#define K_MIN 3\n")
            f.write(f"#define K_MAX 15\n\n")

            # 训练数据样本
            f.write("// Training data sample (first 10 faces)\n")
            f.write("const uint8_t train_faces_sample[10][N_FEATURES] = {\n")
            for i in range(min(10, len(self.X_train))):
                f.write("    {")
                f.write(", ".join([f"{x}" for x in self.X_train[i]]))
                f.write("}," if i < 9 else "}\n")
                if i < 9:
                    f.write(f"  // Person {self.y_train[i]}\n")
            f.write("};\n\n")

            f.write("const uint8_t train_labels_sample[10] = {")
            f.write(", ".join([f"{self.y_train[i]}" for i in range(min(10, len(self.X_train)))]))
            f.write("};\n\n")

            # 测试数据样本
            f.write("// Test data sample (first 5 faces)\n")
            f.write("const uint8_t test_faces_sample[5][N_FEATURES] = {\n")
            for i in range(min(5, len(self.X_test))):
                f.write("    {")
                f.write(", ".join([f"{x}" for x in self.X_test[i]]))
                f.write("}," if i < 4 else "}\n")
                if i < 4:
                    f.write(f"  // Expected: Person {self.y_test[i]}\n")
            f.write("};\n\n")

            f.write("const uint8_t test_labels_sample[5] = {")
            f.write(", ".join([f"{self.y_test[i]}" for i in range(min(5, len(self.X_test)))]))
            f.write("};\n\n")

            # 辅助函数声明
            f.write("// Helper functions (implement in your C code)\n")
            f.write("uint16_t l1_distance(const uint8_t* face1, const uint8_t* face2, uint16_t n_features);\n")
            f.write("uint8_t adaptive_knn_predict(const uint8_t* query_face, uint8_t* confidence);\n")
            f.write("float calculate_confidence(uint8_t k, const uint16_t* distances, const uint8_t* labels);\n\n")

            f.write("#endif // FACE_KNN_DATA_H\n")

        print(f"✓ 已生成 {filename}")

    def generate_verilog_params(self, filename='face_knn_params.vh'):
        """生成Verilog参数文件"""
        print(f"\n生成Verilog参数文件: {filename}")

        with open(filename, 'w') as f:
            f.write("// Face Recognition KNN Accelerator - Parameters\n")
            f.write("// Auto-generated parameter file\n")
            f.write("// Generated by hardware_testbench_generator.py\n\n")

            # 数据集参数
            f.write("// Dataset parameters\n")
            f.write(f"parameter N_TRAIN = {len(self.X_train)};\n")
            f.write(f"parameter N_TEST = {len(self.X_test)};\n")
            f.write(f"parameter D = {self.X_train.shape[1]};  // Feature dimension\n")
            f.write(f"parameter N_CLASSES = {len(np.unique(self.y_train))};\n\n")

            # K值参数
            f.write("// Adaptive K-NN parameters\n")
            f.write(f"parameter K_MIN = 3;\n")
            f.write(f"parameter K_MAX = 15;\n\n")

            # 数据位宽
            f.write("// Data widths\n")
            f.write("parameter FEATURE_WIDTH = 8;  // 8-bit quantized features\n")
            max_dist = self.X_train.shape[1] * 255
            dist_width = int(np.ceil(np.log2(max_dist + 1)))
            f.write(f"parameter DISTANCE_WIDTH = {dist_width};  // Max L1 distance = {max_dist}\n")
            f.write("parameter LABEL_WIDTH = 8;  // Person ID\n")
            f.write("parameter CONFIDENCE_WIDTH = 16;  // Fixed-point Q8.8 for confidence\n\n")

            # 内存地址位宽
            f.write("// Memory addressing\n")
            train_addr_width = int(np.ceil(np.log2(len(self.X_train) * (self.X_train.shape[1] + 1))))
            f.write(f"parameter TRAIN_ADDR_WIDTH = {train_addr_width};  // BRAM address width\n")
            f.write(f"parameter FEATURE_ADDR_WIDTH = {int(np.ceil(np.log2(self.X_train.shape[1])))};\n\n")

            # 流水线参数
            f.write("// Pipeline stages (tune for timing closure)\n")
            f.write("parameter L1_PIPELINE_STAGES = 3;  // Distance calculation pipeline depth\n")
            f.write("parameter SORT_PIPELINE_STAGES = 2;  // Sorting pipeline depth\n")

        print(f"✓ 已生成 {filename}")

    def generate_all_files(self):
        """生成所有硬件文件"""
        print("\n" + "=" * 70)
        print("开始生成所有硬件测试文件")
        print("=" * 70)

        self.generate_bram_mem()
        self.generate_coe_file()
        self.generate_test_vectors(num_tests=20)
        self.generate_c_header()
        self.generate_verilog_params()

        print("\n" + "=" * 70)
        print("文件生成完成!")
        print("=" * 70)
        print("\n生成的文件列表:")
        print("  1. face_train_data_bram.mem  - BRAM仿真初始化文件")
        print("  2. face_train_data.coe       - Vivado综合初始化文件")
        print("  3. face_test_vectors.mem     - Verilog testbench测试向量")
        print("  4. face_knn_data.h           - ARM端C程序头文件")
        print("  5. face_knn_params.vh        - Verilog参数定义文件")

        print("\n使用说明:")
        print("  - .mem文件: 用于Verilog仿真时初始化BRAM")
        print("             在testbench中使用 $readmemh(\"file.mem\", memory_array)")
        print("  - .coe文件: 在Vivado中右键Block Memory Generator -> Customize")
        print("             在Load Init File选项中选择此文件")
        print("  - .h文件:   在ARM端C程序中 #include \"face_knn_data.h\"")
        print("  - .vh文件:  在Verilog顶层模块中 `include \"face_knn_params.vh\"")


def main():
    generator = FaceHardwareGenerator(n_components=50)
    generator.generate_all_files()


if __name__ == "__main__":
    main()